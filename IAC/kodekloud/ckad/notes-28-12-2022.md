# service account

user account for humans (admin, dev)
service account for machines (prometheus, jenkins)

when service account is created
- create a service account object
- then generates a token
- then creates a secret object and stores that token
- then the secret object is linked with service account

we can use the token as
```bash
curl https://<>:6443/api -insecure --header "Authorization: Bearer ${TOKEN}"
```

even without the service account created the default SA token is present in all the pods created in the location
/var/run/secret/kubernetes.io/serviceacccount

```yaml
spec:
  containers:
   - name: dcsdcsd
     image: nginx
  serviceAccountName: dashboard-sa
  automountServiceAccountToken: false # if you don't want token to be mounted in the pod
```

each namespace has its own default SA

by defualt the token has no expiry data or audience bound
use jwt website to decode

TokenRequestAPI
---
KEP 1205 bound service account tokens
- [x] audience bound
- [x] time bound
- [x] object bound

token is generated by service account admission controller thought token request api


enhancement v1.24
 before SA created secret created with token

but now

when SA created it no longer creates secret
you have to 
```bash
kubectl create token serviceaccountName

# if not expiry data specified then default is 1 hr

jq -R 'split(".") | select(length > 0) | .[0],.[1] | @base64d | fromjson' <<< ${token}
```

if you still want to create token and bounded to service account

non expirying token

```yaml
apiVersion: v1
kind: Secret
type: kubernetes.io/service-account-token
metadata:
  name: mysecretname
  annotations:
     kubernetes.io/service-account.name: dashboard-sa
```

# taints and tolerations

taints are like properties of a node such that no pod with toleration of that taint will be able to get scheduled to that tainted node

think of it like a bug approaching a person where person has applied a taint and bug is intolerant to the taint so it cannot bit him of the bug is tolerant to that taint it bit the persion

similarly pods with given toleration to the tainted node can get scheduled

```bash
kubectl taint nodes <node-name> key=value:taint-effect
```

taint-effect -->> what happens to pods that do not tolerate this taint

NoSchedule, PreferNoSchedule, NoExecute

in pod defination
```yaml
spec:
  tolerations:
     - key: "app"
       value: "blue"
       operator: "Equal"
       effect: "NoSchedule"

  containers:
     - name: sdfsvs
```

If noExecute
if there are C, D pod in the node before taint after taint
  D has toleration but C doesn't so it gets evicted
taints and toleration doesnt tell pod to go to a particular node
D can very weel be placed in non tainted node

controlplane nodes are already tainted as
node-role.kubernetes.io/master:NoSchedule


