AWS lambda features
- **bring your own code** : development in lambda is not tightly coupled to AWS so you can easily port code in and out of aws
- **integrates with and extends other aws services** : inside lambda function you can do anything traditional applications can do including calling an aws sdk or involking a 3rd party api whether on aws, in your datacenter or on the internet
- **flexible resource and concurrency model** : instead of scaling by adding servers lambda scales in response to events you configure memory settings and aws handles details such as cpu, network, and I/O throughput
- **flexibile permissions model** : it uses aws IAM to securely grant access to the desired resources and provide fine-grained control to invoke your functions
- **availability and fault tolerance are buit in** : as lambda is a fully managed service HA and fault tolerance are built into the service without needing you to perform any addiotnal configuration
- **pay for value** : pay for the compute time that you consume when code is involed you are billed in 1ms increments


An event is a change in state, a user request, or an update, like an item being placed in a shopping cart in an e-commerce website. When an event occurs, the information is published for other services to consume it

## modes of invocation

1. synchronous invocation
When you invoke a function synchronously, Lambda runs the function and waits for a response. When the function completes, Lambda returns the response from the function's code with additional data, such as the version of the function that was invoked. Synchronous events expect an immediate response from the function invocation. 

The following AWS services invoke Lambda synchronously:

- Amazon API Gateway
- Amazon Cognito
- AWS CloudFormation
- Amazon Alexa
- Amazon Lex
- Amazon CloudFront

2. asynchronous invocation
When you invoke a function asynchronously, events are queued and the requestor doesn't wait for the function to complete. This model is appropriate when the client doesn't need an immediate response. 

With the asynchronous model, you can make use of destinations. Use destinations to send records of asynchronous invocations to other services. (Select the Destinations tab for more information.)

there is a event queue

The following AWS services invoke Lambda asynchronously: 

- Amazon SNS 
- Amazon S3
- Amazon EventBridge 

A destination can send records of asynchronous invocations to other services. You can configure separate destinations for events that fail processing and for events that process successfully. You can configure destinations on a function, a version, or an alias, similarly to how you can configure error handling settings. With destinations, you can address errors and successes without needing to write more code. 

For more information on destinations, see [Configuring destinations](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for asynchronous invocation in the AWS Lambda Developer Guide.

3. polling invocation
This invocation model is designed to integrate with AWS streaming and queuing based services with no code or server management. Lambda will poll (or watch) these services, retrieve any matching events, and invoke your functions. This invocation model supports the following services:

- Amazon Kinesis
- Amazon SQS
- Amazon DynamoDB Streams
With this type of integration, AWS will manage the poller on your behalf and perform synchronous invocations of your function. 

With this model, the retry behavior varies depending on the event source and its configuration.

The configuration of services as event triggers is known as event source mapping. This process occurs when you configure event sources to launch your Lambda functions and then grant theses sources IAM permissions to access the Lambda function. 

Lambda reads events from the following services:

- Amazon DynamoDB
- Amazon Kinesis
- Amazon MQ
- Amazon Managed Streaming for Apache Kafka (MSK)
- self-managed Apache Kafka
- Amazon SQS

## Invocation model error behavior
 
Invocation model | error behaviour
-|-
synchronous | no retries
asynchronous | bult in - retries twice
polling | depends on event source

## Lambda execution environment

### Init phase

```plain
+----------------+--------------+-------------+
| extension Init | Runtime init | func() init |
+----------------+--------------+-------------+

                init phase
```
In this phase, Lambda creates or unfreezes an execution environment with the configured resources, downloads the code for the function and all layers, initializes any extensions, initializes the runtime, and then runs the functionâ€™s initialization code (the code outside the main handler). 

The Init phase happens either during the first invocation, or before function invocations if you have enabled provisioned concurrency.

The Init phase is split into three sub-phases: 
1. Extension init - starts all extensions
2. Runtime init - bootstraps the runtime
3. Function init - runs the function's static code

These sub-phases ensure that all extensions and the runtime complete their setup tasks before the function code runs.

### Invoke phase

```plain
+--------+    +--------+
| invoke | -> | invoke|
+--------+    +--------+
```

In this phase, Lambda invokes the function handler. After the function runs to completion, Lambda prepares to handle another function invocation. 

### Shutdown phase

```plain
+----------+-----------+
| runtime  | extension |
| shutdown | shutdown  | 
+----------+-----------+
```
If the Lambda function does not receive any invocations for a period of time, this phase initiates. In the Shutdown phase, Lambda shuts down the runtime, alerts the extensions to let them stop cleanly, and then removes the environment. Lambda sends a shutdown event to each extension, which tells the extension that the environment is about to be shut down

https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtime-environment.html

## Best practice: Write functions to take advantage of warm starts

1. Store and reference dependencies locally.
2. Limit re-initialization of variables.
3. Add code to check for and reuse existing connections.
4. Use tmp space as transient cache.
5. Check that background processes have completed.
